{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The ERC Handbook Welcome! The ERC Handbook is an extensive compilation of information and resources for everything robotics made by the Electronics and Robotics Club, BITS Goa","title":"Home"},{"location":"#the-erc-handbook","text":"Welcome! The ERC Handbook is an extensive compilation of information and resources for everything robotics made by the Electronics and Robotics Club, BITS Goa","title":"The ERC Handbook"},{"location":"CHANGELOG/","text":"Changelog Unreleased Full Changelog Implemented enhancements: Make Contribution Guidelines #5 Closed issues: Add colcon under catkin #14 Website build error #9 Arrange the subtopics of automation, electronics and mechanics in a logical order #8 Fix the security dependency issue #6 Add a suitable picture for the home page #4 Create initial subsections using the Summer Assignment resources section #3 Remove all initial metadata and add title has ERC handbook #2 Move frontpage to documentation #1 Merged pull requests: [16/08/2020]Added Arduino section under Dev Boards #27 ( Ashutosh781 ) [09/08/2020] Added miscellaneous resources #26 ( hardesh ) [04/08/20] Added information about ROS Parameters #21 ( adbidwai ) [03/08/20] Changelog Test 2 #20 ( veds12 ) changelog test #19 ( veds12 ) [01/08/20] Test1 for auto changelog generator #18 ( veds12 ) [01/08/20] Added information about colcon in GETTING STARTED WITH ROS #17 ( veds12 ) Update mkdocs.yml #12 ( Ashutosh781 ) * This Changelog was automatically generated by github_changelog_generator","title":"Updates"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"Full Changelog Implemented enhancements: Make Contribution Guidelines #5 Closed issues: Add colcon under catkin #14 Website build error #9 Arrange the subtopics of automation, electronics and mechanics in a logical order #8 Fix the security dependency issue #6 Add a suitable picture for the home page #4 Create initial subsections using the Summer Assignment resources section #3 Remove all initial metadata and add title has ERC handbook #2 Move frontpage to documentation #1 Merged pull requests: [16/08/2020]Added Arduino section under Dev Boards #27 ( Ashutosh781 ) [09/08/2020] Added miscellaneous resources #26 ( hardesh ) [04/08/20] Added information about ROS Parameters #21 ( adbidwai ) [03/08/20] Changelog Test 2 #20 ( veds12 ) changelog test #19 ( veds12 ) [01/08/20] Test1 for auto changelog generator #18 ( veds12 ) [01/08/20] Added information about colcon in GETTING STARTED WITH ROS #17 ( veds12 ) Update mkdocs.yml #12 ( Ashutosh781 ) * This Changelog was automatically generated by github_changelog_generator","title":"Unreleased"},{"location":"about/","text":"About Us We are a group of students passionate about Robotics and have many student research projects in progress. You can find out more about the ERC at our website or our github profile . If you have any suggestions or contributions to offer, feel free to open an issue or contact one of the team at ERC.","title":"About Us"},{"location":"about/#about-us","text":"We are a group of students passionate about Robotics and have many student research projects in progress. You can find out more about the ERC at our website or our github profile . If you have any suggestions or contributions to offer, feel free to open an issue or contact one of the team at ERC.","title":"About Us"},{"location":"misc/","text":"Miscellaneous Resources Talk Series / Seminars / Podcasts: Artificial Intelligence Podcast by Lex Fridman Robotics Today MIT RoboSeminars Stanford - Robotics and Autonomous Systems Seminar CMU RI Robotics Seminars List of Mailing lists and Google Groups Robotics Worldwide European Robotics AI Robotics Systems Neuroscience ML-news Connectionists UAI Reinforcement Learning Deep Learning Neuromorphic Engineering Computer Vision Artificial Life Genetic Programming","title":"Miscellaneous Resources"},{"location":"misc/#miscellaneous-resources","text":"","title":"Miscellaneous Resources"},{"location":"misc/#talk-series-seminars-podcasts","text":"Artificial Intelligence Podcast by Lex Fridman Robotics Today MIT RoboSeminars Stanford - Robotics and Autonomous Systems Seminar CMU RI Robotics Seminars","title":"Talk Series / Seminars / Podcasts:"},{"location":"misc/#list-of-mailing-lists-and-google-groups","text":"Robotics Worldwide European Robotics AI Robotics Systems Neuroscience ML-news Connectionists UAI Reinforcement Learning Deep Learning Neuromorphic Engineering Computer Vision Artificial Life Genetic Programming","title":"List of Mailing lists and Google Groups"},{"location":"automation/intro/","text":"Introduction","title":"Introduction"},{"location":"automation/intro/#introduction","text":"","title":"Introduction"},{"location":"automation/ROS/ros/","text":"Getting Started with Robot Operating System (ROS)\u201d 1. What is ROS? For someone completely new to ROS, the best way to think about it is a collection of tools and frameworks which make automating robotics projects much easier. Every ROS project has a certain structure which you have to follow. Your job would be to fill in the automation code along defining how the different parts of your code are communicating with one another. Once this is done, the underlying ROS framework takes care of the actual networking and connections. ROS also has the advantage of having a large open source community with tons of packages. This means you have a lot of prewritten code to help with your project and you don\u2019t have to start from scratch. Don\u2019t worry if you are still confused, you will start to get a better understanding with some hands on experience. \u200bTo get a better understanding of what ROS is and why it exists, checkout out these videos (\u200b 1 \u200b, 2 ). A ROS system can be visualized as a graph where all the vertices are \u200bnodes and the edges between them are known as \u200btopics. In simple terms nodes are programs that perform a particular task and send out/receive data in the form of messages. These messages are exchanged between two nodes over the topic (edge) connecting them. An example of a typical ROS system is given in the figure to the left wherein \u201crobot\u201d, \u201claser\u201d, \u201cmap\u201d, \u201clocalisation\u201d and \u201cplanner\u201d are the nodes and the arrows connecting the nodes are the topics. An arrow \u200b from A to B indicates that the topic carries messages from node \u200bA to node B. 2. Reference Material While we have tried our best to provide a concise introduction to the basic concepts in this document, there are a lot of other much more thorough and complete resources that you should follow. This document can be treated more as a reference guide with some useful tips for beginners. The two most useful resources you can go through are - Programming Robots with ROS :\u200b A Practical Introduction to the Robot Operating System by Morgan Quigley. ROSwiki\u200b tutorials : The official ROS tutorials . Both of these have detailed implementation guides on the basic concepts. The ROSwiki is more concise while the book goes into more detail. We strongly recommend that you go through the first 4 chapters of the book and try out all the implementation examples yourselves. Along with these you can check out The Construct youtube \u200bvideos\u200b. 3. Basic Concepts Now let\u2019s get familiar with some very commonly used terms in ROS development. Along with the following introduction you should go through \u200b Chapter 1 and 2 \u200b of Morgan Quigley for in depth explanation and examples. Catkin: Catkin is the build system used for ROS. This means that after you have written all your code, defined your message files etc, you will run catkin to join everything together and compile any dependencies you have. To build packages you must have a catkin workspace where all your projects are contained. You will have to use it to \u200b build \u200b not only yours but any other packages that may be in your workspace. Click \u200b here \u200b to learn more about catkin. A catkin workspace or package can be built running either of these two commands : catkin_make or catkin build in the root of your catkin workspace. Note : The command used for building a workspace should be consistent everytime, i.e. if the workspace was built using catkin_make the very first time while initializing the workspace, all the subsequent builds should be done using catkin_make. To change the method of build in a pre existing workspace, you can use the command catkin clean which will clear everything except the source space (src folder) of the workspace. It can then be rebuilt using the desired command. Colcon: Colcon is another build system just like catkin. It comes with a vast array of features which can be used to organise your workspace. Similar to catkin, to build a workspace, you need to run colcon build in the root of the folder your workspace. You can check out the documentation of colcon to explore more features. Workspace: \u200bA ROS workspace is basically a directory with a certain hierarchy wherein all your sets of related ROS codes live. A workspace contains packages which in turn contain the code for nodes amongst other things. You can have multiple workspaces on your computer but work in only one at a time. Follow this \u200b tutorial in order to set up your own catkin workspace. After following the steps in the above tutorial, upon entering your workspace directory, you will see three directories: \u200b build , \u200b devel \u200band \u200b src . ROS Package: \u200b All the codes and software in ROS is organised in the form of packages. A package may contain ROS Nodes, libraries used in those codes, message and service definitions and all the dependencies. Follow \u200b this \u200b tutorial to know how to create a ROS package. (Note: Follow the \u2018catkin\u2019 way instead of \u2018rosbuild\u2019). After creating the package you\u2019ll see two files \u200bCMakeLists.txt and package.xml. We\u2019ll be using (editing) these files many times as we proceed to work with ROS. Apart from these files there is a directory \u201csrc\u201d. This is the place where the code for ROS nodes of the package lives (as mentioned before, nodes are nothing but programs that perform specific tasks). Once you have created your ROS package you have to build it so that you can use it. Follow \u200b this \u200b tutorial to see how to build your package. ROS Nodes and Packages: A \u200bnode is an executable file (could be python or C++) which performs a specific task and communicates with other nodes through \u200b topics. \u200bTwo main ways this is done is through publisher-subscriber relationship or services. All of the programming involved in creating a ROS based project is done while writing these nodes. Topics are\u200b the channels over which the messages of different kinds are transmitted between nodes, read \u200b this \u200b wiki to know more. ROS messages have to be specially defined for each user defined topic. Apart from the standard message types that come with ROS like \u200bstring, int32, etc. you can also define your custom message types in ROS for custom uses. Refer to parts 2 and 3 this \u200b tutorial to see how you can define and use a custom message type. Note: A single node can simultaneously act as a subscriber to one topic and a publisher of another topic and a server for one service and the client for another. Publisher - Subscriber Model: \u200bThis is a model through which two nodes can exchange data in the form of messages asynchronously, usually used when a one way stream of information is involved. For example, suppose you are developing a self-driving car and you have a node which processes the video feed from a camera to detect street signs. Whenever it detects a sign, it needs to communicate its type and distance from the car to another node which will use this information to control the speed of the car. In this scenario your sign detection node will be a publisher which publishes data about the signs it detects to a specific topic, say signs. \u200bYour controller node will be a subscriber which will subscribe to the \u200b signs \u200b topic and perform a certain task whenever it receives a message on this topic. Publisher: The publisher object of a ROS node publishes the data in the form of messages over a topic. There is a particular rate (which the user defines) at which the messages get published. Subscriber: The data published by the publisher of one ROS node can be received or \u2018subscribed\u2019 through the Subscriber object of a ROS node. The Subscriber object subscribes to the topic over which any publisher publishes the messages. Every Subscriber object is associated with a callback function which gets called everytime a message is published over the topic. You can check out how to implement a basic server-client for C++\u200b or \u200b pytho\u200bn in the ROS wiki or \u200bChapter 3\u200b of Morgan Quigley. Services: Another common mode of communication, especially suited when there is a transaction style relationship between the two nodes is the service - consisting of a server and a client . For example consider in your self driving car, you have one node to control the movement of the car and another to plan an optimal route to your destination. In such a scenario, the main control node would be the \u200b client \u200bfor the route planning \u200b server . This means that whenever the controller requires a route to be planned, supposed it finds out the route is blocked up ahead, then it would send a request to the server. This request would consist of the current location, the destination as well as any preferences the controller might have (like faster/more comfortable). The server would then compute an optimal route and return it to the server as the response. Client: \u200bThis is the node which sends requests to a server. In the client code, you can create a special function which acts as a proxy between the client and server. Whenever you call the function, it sends a request to the server with the arguments passed to it as parameters. Server: \u200bThis node constantly monitors for requests from the client. Whenever it receives one, it carries out the required task independently of the client and sends back the response when the task is complete. You can check out how to implement a basic server-client for C++\u200b or \u200bpython \u200b in the ROS wiki or Chapter 4 \u200b of Morgan Quigley. 4. Getting things running Getting a complete ROS system up and running requires a bit more work than executing a single file. Check out \u200b Chapter 20 of Morgan Quigley for more detailed explanation as well as examples for all of the following tools. ROS Master: Before running the functional nodes in your system, you should first understand ROS Master. This can be visualised as a central server to which all nodes are connected by default. It allows any node to look up information about any other node. This is essential for connecting nodes within the system. For eg. when a node (A) needs to subscribe to a topic published by another node (B), it will get the network address of node B from ROS Master. As you might guess, a running ROS Master is necessary for every ROS system since, without it, the nodes won\u2019t be able to connect with each other. Thus whenever you are setting up your system of nodes the first command must run in the terminal is \u200b roscore which initializes ROS Master. The ROS wiki has a section on ROS Master \u200b here \u200b or you can check out\u200b Chapter 2 \u200bof Morgan Quigley. rosrun: Once you start the ROS Master, you can now start your own ROS nodes. For this ROS has a special command called rosrun which lets you run the executable files for your node from anywhere. The format for rosrun is - rosrun <package_name> <executable_name>.py (Replace and appropriately) A note on node file permissions: If using python, before attempting to run any ROS nodes that you have written, make sure that you have given executable permission to the code files. For more info on linux file permission look \u200b here\u200b . The command to do this is - chmod u+x <executable_name>.py (Replace appropriately) A note on multiple terminal windows: Whenever you run \u200b roscore\u200b or your own ROS node, it will hold the terminal until it is killed. So if you are running multiple nodes, you will need to run each one in a separate terminal window (\u200b terminator \u200b to your rescue!). A note on the tab key in terminal: * Typing out long commands into the terminal can get tedious. So ros has a handy capability of completing your commands for you. Whenever you are using \u200b rosrun\u200b or roslaunch\u200b, you can type out the first few letters in the package name and then press the Tab key* on your keyboard. At this point, the package name will be autocomplete, saving you a lot of typing. Try it out, this works with other terminal commands too! roslaunch: ROS projects can involve a lot of nodes and launching them one by one can be a hassle. roslaunch is a command which lets you launch a specific set of nodes at once in a single terminal by using launch-files. These files usually contain a list of nodes and other related info and are generally stored in the \u2018launch\u2019 directory inside a package. Follow this tutorial to learn how to make a launch file. roscd: roscd is a command line tool which allows you to navigate or \u2018cd\u2019 (change directory) to (in command line terms) a package without knowing its exact path. Note: The workspace in which the package is present needs to be sourced. E.g. If you wish to navigate into the \u2018turtlebot3_gazebo\u2019 package you\u2019ll just type the following command in the terminal: roscd turtlebot3_gazebo rqt_graph: Once you have your system running, you can obtain a diagram along with other details of the system by running the rqt_graph command in another terminal window.","title":"Getting Started with ROS"},{"location":"automation/ROS/ros/#getting-started-with-robot-operating-system-ros","text":"","title":"Getting Started with Robot Operating System (ROS)\""},{"location":"automation/ROS/ros/#1-what-is-ros","text":"For someone completely new to ROS, the best way to think about it is a collection of tools and frameworks which make automating robotics projects much easier. Every ROS project has a certain structure which you have to follow. Your job would be to fill in the automation code along defining how the different parts of your code are communicating with one another. Once this is done, the underlying ROS framework takes care of the actual networking and connections. ROS also has the advantage of having a large open source community with tons of packages. This means you have a lot of prewritten code to help with your project and you don\u2019t have to start from scratch. Don\u2019t worry if you are still confused, you will start to get a better understanding with some hands on experience. \u200bTo get a better understanding of what ROS is and why it exists, checkout out these videos (\u200b 1 \u200b, 2 ). A ROS system can be visualized as a graph where all the vertices are \u200bnodes and the edges between them are known as \u200btopics. In simple terms nodes are programs that perform a particular task and send out/receive data in the form of messages. These messages are exchanged between two nodes over the topic (edge) connecting them. An example of a typical ROS system is given in the figure to the left wherein \u201crobot\u201d, \u201claser\u201d, \u201cmap\u201d, \u201clocalisation\u201d and \u201cplanner\u201d are the nodes and the arrows connecting the nodes are the topics. An arrow \u200b from A to B indicates that the topic carries messages from node \u200bA to node B.","title":"1. What is ROS?"},{"location":"automation/ROS/ros/#2-reference-material","text":"While we have tried our best to provide a concise introduction to the basic concepts in this document, there are a lot of other much more thorough and complete resources that you should follow. This document can be treated more as a reference guide with some useful tips for beginners. The two most useful resources you can go through are - Programming Robots with ROS :\u200b A Practical Introduction to the Robot Operating System by Morgan Quigley. ROSwiki\u200b tutorials : The official ROS tutorials . Both of these have detailed implementation guides on the basic concepts. The ROSwiki is more concise while the book goes into more detail. We strongly recommend that you go through the first 4 chapters of the book and try out all the implementation examples yourselves. Along with these you can check out The Construct youtube \u200bvideos\u200b.","title":"2. Reference Material"},{"location":"automation/ROS/ros/#3-basic-concepts","text":"Now let\u2019s get familiar with some very commonly used terms in ROS development. Along with the following introduction you should go through \u200b Chapter 1 and 2 \u200b of Morgan Quigley for in depth explanation and examples. Catkin: Catkin is the build system used for ROS. This means that after you have written all your code, defined your message files etc, you will run catkin to join everything together and compile any dependencies you have. To build packages you must have a catkin workspace where all your projects are contained. You will have to use it to \u200b build \u200b not only yours but any other packages that may be in your workspace. Click \u200b here \u200b to learn more about catkin. A catkin workspace or package can be built running either of these two commands : catkin_make or catkin build in the root of your catkin workspace. Note : The command used for building a workspace should be consistent everytime, i.e. if the workspace was built using catkin_make the very first time while initializing the workspace, all the subsequent builds should be done using catkin_make. To change the method of build in a pre existing workspace, you can use the command catkin clean which will clear everything except the source space (src folder) of the workspace. It can then be rebuilt using the desired command. Colcon: Colcon is another build system just like catkin. It comes with a vast array of features which can be used to organise your workspace. Similar to catkin, to build a workspace, you need to run colcon build in the root of the folder your workspace. You can check out the documentation of colcon to explore more features. Workspace: \u200bA ROS workspace is basically a directory with a certain hierarchy wherein all your sets of related ROS codes live. A workspace contains packages which in turn contain the code for nodes amongst other things. You can have multiple workspaces on your computer but work in only one at a time. Follow this \u200b tutorial in order to set up your own catkin workspace. After following the steps in the above tutorial, upon entering your workspace directory, you will see three directories: \u200b build , \u200b devel \u200band \u200b src . ROS Package: \u200b All the codes and software in ROS is organised in the form of packages. A package may contain ROS Nodes, libraries used in those codes, message and service definitions and all the dependencies. Follow \u200b this \u200b tutorial to know how to create a ROS package. (Note: Follow the \u2018catkin\u2019 way instead of \u2018rosbuild\u2019). After creating the package you\u2019ll see two files \u200bCMakeLists.txt and package.xml. We\u2019ll be using (editing) these files many times as we proceed to work with ROS. Apart from these files there is a directory \u201csrc\u201d. This is the place where the code for ROS nodes of the package lives (as mentioned before, nodes are nothing but programs that perform specific tasks). Once you have created your ROS package you have to build it so that you can use it. Follow \u200b this \u200b tutorial to see how to build your package. ROS Nodes and Packages: A \u200bnode is an executable file (could be python or C++) which performs a specific task and communicates with other nodes through \u200b topics. \u200bTwo main ways this is done is through publisher-subscriber relationship or services. All of the programming involved in creating a ROS based project is done while writing these nodes. Topics are\u200b the channels over which the messages of different kinds are transmitted between nodes, read \u200b this \u200b wiki to know more. ROS messages have to be specially defined for each user defined topic. Apart from the standard message types that come with ROS like \u200bstring, int32, etc. you can also define your custom message types in ROS for custom uses. Refer to parts 2 and 3 this \u200b tutorial to see how you can define and use a custom message type. Note: A single node can simultaneously act as a subscriber to one topic and a publisher of another topic and a server for one service and the client for another. Publisher - Subscriber Model: \u200bThis is a model through which two nodes can exchange data in the form of messages asynchronously, usually used when a one way stream of information is involved. For example, suppose you are developing a self-driving car and you have a node which processes the video feed from a camera to detect street signs. Whenever it detects a sign, it needs to communicate its type and distance from the car to another node which will use this information to control the speed of the car. In this scenario your sign detection node will be a publisher which publishes data about the signs it detects to a specific topic, say signs. \u200bYour controller node will be a subscriber which will subscribe to the \u200b signs \u200b topic and perform a certain task whenever it receives a message on this topic. Publisher: The publisher object of a ROS node publishes the data in the form of messages over a topic. There is a particular rate (which the user defines) at which the messages get published. Subscriber: The data published by the publisher of one ROS node can be received or \u2018subscribed\u2019 through the Subscriber object of a ROS node. The Subscriber object subscribes to the topic over which any publisher publishes the messages. Every Subscriber object is associated with a callback function which gets called everytime a message is published over the topic. You can check out how to implement a basic server-client for C++\u200b or \u200b pytho\u200bn in the ROS wiki or \u200bChapter 3\u200b of Morgan Quigley. Services: Another common mode of communication, especially suited when there is a transaction style relationship between the two nodes is the service - consisting of a server and a client . For example consider in your self driving car, you have one node to control the movement of the car and another to plan an optimal route to your destination. In such a scenario, the main control node would be the \u200b client \u200bfor the route planning \u200b server . This means that whenever the controller requires a route to be planned, supposed it finds out the route is blocked up ahead, then it would send a request to the server. This request would consist of the current location, the destination as well as any preferences the controller might have (like faster/more comfortable). The server would then compute an optimal route and return it to the server as the response. Client: \u200bThis is the node which sends requests to a server. In the client code, you can create a special function which acts as a proxy between the client and server. Whenever you call the function, it sends a request to the server with the arguments passed to it as parameters. Server: \u200bThis node constantly monitors for requests from the client. Whenever it receives one, it carries out the required task independently of the client and sends back the response when the task is complete. You can check out how to implement a basic server-client for C++\u200b or \u200bpython \u200b in the ROS wiki or Chapter 4 \u200b of Morgan Quigley.","title":"3. Basic Concepts"},{"location":"automation/ROS/ros/#4-getting-things-running","text":"Getting a complete ROS system up and running requires a bit more work than executing a single file. Check out \u200b Chapter 20 of Morgan Quigley for more detailed explanation as well as examples for all of the following tools. ROS Master: Before running the functional nodes in your system, you should first understand ROS Master. This can be visualised as a central server to which all nodes are connected by default. It allows any node to look up information about any other node. This is essential for connecting nodes within the system. For eg. when a node (A) needs to subscribe to a topic published by another node (B), it will get the network address of node B from ROS Master. As you might guess, a running ROS Master is necessary for every ROS system since, without it, the nodes won\u2019t be able to connect with each other. Thus whenever you are setting up your system of nodes the first command must run in the terminal is \u200b roscore which initializes ROS Master. The ROS wiki has a section on ROS Master \u200b here \u200b or you can check out\u200b Chapter 2 \u200bof Morgan Quigley. rosrun: Once you start the ROS Master, you can now start your own ROS nodes. For this ROS has a special command called rosrun which lets you run the executable files for your node from anywhere. The format for rosrun is - rosrun <package_name> <executable_name>.py (Replace and appropriately) A note on node file permissions: If using python, before attempting to run any ROS nodes that you have written, make sure that you have given executable permission to the code files. For more info on linux file permission look \u200b here\u200b . The command to do this is - chmod u+x <executable_name>.py (Replace appropriately) A note on multiple terminal windows: Whenever you run \u200b roscore\u200b or your own ROS node, it will hold the terminal until it is killed. So if you are running multiple nodes, you will need to run each one in a separate terminal window (\u200b terminator \u200b to your rescue!). A note on the tab key in terminal: * Typing out long commands into the terminal can get tedious. So ros has a handy capability of completing your commands for you. Whenever you are using \u200b rosrun\u200b or roslaunch\u200b, you can type out the first few letters in the package name and then press the Tab key* on your keyboard. At this point, the package name will be autocomplete, saving you a lot of typing. Try it out, this works with other terminal commands too! roslaunch: ROS projects can involve a lot of nodes and launching them one by one can be a hassle. roslaunch is a command which lets you launch a specific set of nodes at once in a single terminal by using launch-files. These files usually contain a list of nodes and other related info and are generally stored in the \u2018launch\u2019 directory inside a package. Follow this tutorial to learn how to make a launch file. roscd: roscd is a command line tool which allows you to navigate or \u2018cd\u2019 (change directory) to (in command line terms) a package without knowing its exact path. Note: The workspace in which the package is present needs to be sourced. E.g. If you wish to navigate into the \u2018turtlebot3_gazebo\u2019 package you\u2019ll just type the following command in the terminal: roscd turtlebot3_gazebo rqt_graph: Once you have your system running, you can obtain a diagram along with other details of the system by running the rqt_graph command in another terminal window.","title":"4. Getting things running"},{"location":"automation/ROS/ros_p2/","text":"ROS Parameters and Parameter Server Parameter server is a collection of values or parameters that can be retrieved or modified by the nodes during runtime upon requests through command prompt, nodes or launch files. Parameters are intended to be static, globally available values like integers, floats, strings and boolean values and can be stored independently or within a YAML file. Parameters are meant to be gloablly viewable so nodes can easily inspect the configuration state of the system and modify if necessary. Accessing and setting Parameters Via command line Parameters can be accessed, modified or deleted using the rosparam command line utility in the rosbash suite of terminal commands. 1) To list all the parameters : rosparam list Or to list all the parameters in a specific namespace : rosparam list </namespace> 2) To assign a value to an already existing parameter or to set a new one : rosparam set <parameter_name> <parameter_value> Note : You can also load the parameters into the parameter server from a YAML file using < br /> ``` rosparam load < filename > < namepsace > ``` 3) To get/read a parameter value : rosparam get <parameter_name> Note : You can also dump/save the parameters into a YAML file from parameter server using rosparam dump <filename> <namespace> For more insights regarding the rosparam tool refer to this link. Via the rospy API library Parameters from the parameter server can be accessed and modified using rospy API library. This is generally used when the parameters are to be used by a node during the runtime. Refer this link for more imformation on handling parameters using rospy API library. Via launch files Parameters can be set, created and loaded into the parameter server while creating launch files. Refer to this link ROSWiki for more information on handling parameters in launch files. Following links can be referred to for more insights on parameters and parameter server 1 , 2 , 3","title":"ROS Parameters"},{"location":"automation/ROS/ros_p2/#ros-parameters-and-parameter-server","text":"Parameter server is a collection of values or parameters that can be retrieved or modified by the nodes during runtime upon requests through command prompt, nodes or launch files. Parameters are intended to be static, globally available values like integers, floats, strings and boolean values and can be stored independently or within a YAML file. Parameters are meant to be gloablly viewable so nodes can easily inspect the configuration state of the system and modify if necessary.","title":"ROS Parameters and Parameter Server"},{"location":"automation/ROS/ros_p2/#accessing-and-setting-parameters","text":"","title":"Accessing and setting Parameters"},{"location":"automation/ROS/ros_p2/#via-command-line","text":"Parameters can be accessed, modified or deleted using the rosparam command line utility in the rosbash suite of terminal commands. 1) To list all the parameters : rosparam list Or to list all the parameters in a specific namespace : rosparam list </namespace> 2) To assign a value to an already existing parameter or to set a new one : rosparam set <parameter_name> <parameter_value> Note : You can also load the parameters into the parameter server from a YAML file using < br /> ``` rosparam load < filename > < namepsace > ``` 3) To get/read a parameter value : rosparam get <parameter_name> Note : You can also dump/save the parameters into a YAML file from parameter server using rosparam dump <filename> <namespace> For more insights regarding the rosparam tool refer to this link.","title":"Via command line"},{"location":"automation/ROS/ros_p2/#via-the-rospy-api-library","text":"Parameters from the parameter server can be accessed and modified using rospy API library. This is generally used when the parameters are to be used by a node during the runtime. Refer this link for more imformation on handling parameters using rospy API library.","title":"Via the rospy API library"},{"location":"automation/ROS/ros_p2/#via-launch-files","text":"Parameters can be set, created and loaded into the parameter server while creating launch files. Refer to this link ROSWiki for more information on handling parameters in launch files. Following links can be referred to for more insights on parameters and parameter server 1 , 2 , 3","title":"Via launch files"},{"location":"automation/ROS/setting_up/","text":"Preparing your Development Environment One of the most essential and widely used tools for robot automation in Robot Operating System or ROS . This section will guide you through how to setup ROS and other tools on your computer. 1. Operating System Robotics Development relies heavily on Linux . We recommend using Ubuntu 18.04 since it is the most widely used and supported variant of Linux. If you already have Ubuntu 16.04, this is also OK, although for versions older than this we recommend upgrading to 18.04. For those who currently have Windows as the only OS on their machine, the best way to start using Ubuntu would be to dual boot . Here is a guide on how to do this . For MacOS users, dual booting is an option but we recommend using up a virtual machine. If you are unable to dual boot for any reason, you can try setting up a virtual machine . The first step in this is to install a virtualisation software. For Windows you can use either VirtualBox (free) or Vmware Workstation and for MacOS either VirtualBox (free), Vmware Fusion or Parallels. After getting one of the above, follow the instructions given here (skip ahead to the Download Image section). After completing the given procedure you will be equipped with all the basic tools required for Robotics including ROS, catkin and git. In the unfortunate case that the above options do not work , for Windows users there is still a way - WSL . Do be warned however, this path is fraught with frustration and much debugging. Only continue if you have exhausted other options. For a guide on setting up WSL for ROS, look here . For those whom none of the above are possible, consider using the online browser based ROS Development Studio . Keep in mind that it has a limited access time per week and performance may be questionable. 2. Robot Operating System (ROS) Note that this part is unnecessary if you followed the given instructions to set up a VM. For everyone else, this part is essential . Different versions of Ubuntu need different variants of ROS. Instructions given below - \u2794 Ubuntu 18.04 : ROS Melodic \u2794 Ubuntu 16.04 : ROS Kinetic 3. Useful tools to make your life easier Git\u200b : Fundamental tool in open source software development. Used for version control and sharing of code. sudo apt install git Terminator \u200b : Terminal Emulator useful for having multiple terminals in a window. sudo apt install terminator Code Editors : A good editor can go a long way in boosting productivity. We recommend \u200b VSCode \u200b which has plugins for python and ROS. A comprehensive guide for how to integrate ROS into your favourite IDE can be found \u200bhere \u200b. 4. ROS Packages You can install already developed ROS packages using the apt (package manager for Ubuntu). Replace name of the ROS package sudo apt install ros- $ROS_DISTRO -<package_name> For example Turtlebot is one of the most commonly used ground bots for simulation purposes. You can install Turtlebot and it\u2019s related packages using the following command - sudo apt install ros- $ROS_DISTRO -turtlebot3-* 5. Tips for getting things to work + some helpful facts Make a habit of running sudo apt update before installing packages in linux. For the uninitiated, your bashrc file is the configuration file for your bash terminal (the thing you type commands into). It\u2019s usually located in your home directory at ~/.bashrc For more info, check out this . Don\u2019t forget to source the workspace you want to use. For convenience you can source the workspace on startup by editing your .bashrc file to include the following line. Replace with the path of your workspace source <workspace_path>/devel/setup.bash You cannot source two workspaces at the same time. Anaconda and ROS cannot be used in the same environment because they have a conflicting python path. As given here , to deal with this, edit your bashrc file by commenting the anaconda python path like this - // export PATH = \"/home//anaconda3/bin: $PATH \" Use python pip to install python dependencies. Anaconda should be avoided.","title":"Setting Up"},{"location":"automation/ROS/setting_up/#preparing-your-development-environment","text":"One of the most essential and widely used tools for robot automation in Robot Operating System or ROS . This section will guide you through how to setup ROS and other tools on your computer.","title":"Preparing your Development Environment"},{"location":"automation/ROS/setting_up/#1-operating-system","text":"Robotics Development relies heavily on Linux . We recommend using Ubuntu 18.04 since it is the most widely used and supported variant of Linux. If you already have Ubuntu 16.04, this is also OK, although for versions older than this we recommend upgrading to 18.04. For those who currently have Windows as the only OS on their machine, the best way to start using Ubuntu would be to dual boot . Here is a guide on how to do this . For MacOS users, dual booting is an option but we recommend using up a virtual machine. If you are unable to dual boot for any reason, you can try setting up a virtual machine . The first step in this is to install a virtualisation software. For Windows you can use either VirtualBox (free) or Vmware Workstation and for MacOS either VirtualBox (free), Vmware Fusion or Parallels. After getting one of the above, follow the instructions given here (skip ahead to the Download Image section). After completing the given procedure you will be equipped with all the basic tools required for Robotics including ROS, catkin and git. In the unfortunate case that the above options do not work , for Windows users there is still a way - WSL . Do be warned however, this path is fraught with frustration and much debugging. Only continue if you have exhausted other options. For a guide on setting up WSL for ROS, look here . For those whom none of the above are possible, consider using the online browser based ROS Development Studio . Keep in mind that it has a limited access time per week and performance may be questionable.","title":"1. Operating System"},{"location":"automation/ROS/setting_up/#2-robot-operating-system-ros","text":"Note that this part is unnecessary if you followed the given instructions to set up a VM. For everyone else, this part is essential . Different versions of Ubuntu need different variants of ROS. Instructions given below - \u2794 Ubuntu 18.04 : ROS Melodic \u2794 Ubuntu 16.04 : ROS Kinetic","title":"2. Robot Operating System (ROS)"},{"location":"automation/ROS/setting_up/#3-useful-tools-to-make-your-life-easier","text":"Git\u200b : Fundamental tool in open source software development. Used for version control and sharing of code. sudo apt install git Terminator \u200b : Terminal Emulator useful for having multiple terminals in a window. sudo apt install terminator Code Editors : A good editor can go a long way in boosting productivity. We recommend \u200b VSCode \u200b which has plugins for python and ROS. A comprehensive guide for how to integrate ROS into your favourite IDE can be found \u200bhere \u200b.","title":"3. Useful tools to make your life easier"},{"location":"automation/ROS/setting_up/#4-ros-packages","text":"You can install already developed ROS packages using the apt (package manager for Ubuntu). Replace name of the ROS package sudo apt install ros- $ROS_DISTRO -<package_name> For example Turtlebot is one of the most commonly used ground bots for simulation purposes. You can install Turtlebot and it\u2019s related packages using the following command - sudo apt install ros- $ROS_DISTRO -turtlebot3-*","title":"4. ROS Packages"},{"location":"automation/ROS/setting_up/#5-tips-for-getting-things-to-work-some-helpful-facts","text":"Make a habit of running sudo apt update before installing packages in linux. For the uninitiated, your bashrc file is the configuration file for your bash terminal (the thing you type commands into). It\u2019s usually located in your home directory at ~/.bashrc For more info, check out this . Don\u2019t forget to source the workspace you want to use. For convenience you can source the workspace on startup by editing your .bashrc file to include the following line. Replace with the path of your workspace source <workspace_path>/devel/setup.bash You cannot source two workspaces at the same time. Anaconda and ROS cannot be used in the same environment because they have a conflicting python path. As given here , to deal with this, edit your bashrc file by commenting the anaconda python path like this - // export PATH = \"/home//anaconda3/bin: $PATH \" Use python pip to install python dependencies. Anaconda should be avoided.","title":"5. Tips for getting things to work + some helpful facts"},{"location":"electronics/intro/","text":"Introduction","title":"Introduction"},{"location":"electronics/intro/#introduction","text":"","title":"Introduction"},{"location":"electronics/Development_Boards/Arduino/","text":"Arduino The Arduino is basically a very accessible and easy to program microcontroller. Unlike other microcontrollers, which need knowledge of registers and ports, the Arduino is programmed by a very basic C-derived language. This video explains what an Arduino is, what it is capable of, and the numerous projects one can use it for. Arduino Board Layout The above diagram shows an Arduino UNO board with all the parts labelled and explained below: USB Port: Arduino can be powered by connecting it to your computer using a USB cable. It is also used for uploading code and communicating via the serial port. Power Jack: Used to power an arduino directly from a wall adaptor. Voltage Regulator: Controls and stabilises the voltage used by the Arduino and its components. Crystal Oscillator: A microcontroller is a clock based device. The crystal oscillator present on the arduino generates a clock of frequency 16MHz. Reset controllers: Resetting the arduino board starts the execution of a program from the beginning. Arduino can be reset in 2 ways : by pressing the reset button (17) and sending a 0V signal to the RESET pin (5). 3.3V power 5V power GND (0V) VIN: This pin can be used to power the arduino board from an external power source, from 7-20V. Analog Pins: These pins (labeled A0-A5) can be used to read continuous analog values (between 0 and 5V). They are often used to interface the Arduino with analog sensors. Main Microcontroller: This IC is the main microcontroller, that executes the code you program it with. ICSP Pin: Can be used to program the arduino board\u2019s firmware. For advanced users only. Power LED indicator: Indicates whether the board is powered up correctly. TX/RX LEDs: The TX/RX pins flash to indicate transfer/receival of serial data between the computer and Arduino. Digital I/O Pins: These pins can be programmed as input/output pins. When used as output, they can be set HIGH (+5V) or LOW (0V). Analog Reference(AREF): Can be used to set an external reference voltage(0-5V) as the upper limit for analog input pins. Reset Button: Pressing it causes the Arduino to restart its code. The Blink Sketch The Blink sketch is like the \u201cHello World\u201d program in the Arduino world. It simply consists of blinking the onboard LED (labeled \u2018L\u2019). No actual circuit connections are required! Code You can copy the code from here . How to code an Arduino in Arduino IDE Download and install Arduino Software (IDE) from here . The Integrated Development Environment (IDE) is a common coding environment for all arduino boards. Open the IDE and a new sketch will open up which would look like the image below. Sketch is just a name arduino uses for a program. Then just paste the entire code here. Now connect your Arduino UNO board to your PC using an A B USB cable and select the option \u201cArduino/Genuino Uno\u201d under Tools > Board menu. Also make sure to select the correct port through which the PC is connected to the board under Tools > Port menu. Click on the \u201ctick\u201d button in upper left corner to compile the code and check for errors. After resolving any and all errors click on the \u201carrow\u201d button next to it to upload the code to the board. After successful upload the Arduino Uno will start executing the code while drawing power from the PC through the USB cable. Explanation Every Arduino sketch must have two particular functions: void setup() The setup() function is called when a sketch starts and will only run once, after each powerup or reset of the Arduino board. void loop() This function does precisely what its name suggests, that is loops consecutively, allowing your program to change and respond. Whatever code you write inside loop() will keep running as long as the Arduino is receiving power. Let us examine the Blink sketch now, line by line. int led = 13 ; This line assigns a name to the pin that the LED is attached to, i.e. pin 13. Then we have the setup() function, which runs only once. It includes the following line. pinMode ( led , OUTPUT ); This tells the Arduino to configure that pin as an output. Then we have the following loop() function. void loop () { digitalWrite ( led , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( led , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } The digitalWrite() function tells a pin to either switch on (HIGH, or +5V) or off (LOW, or 0V). The delay() function tells the Arduino to wait for a specified number of milliseconds. Reading Analog Values The following circuit reads the voltage from a potentiometer and sends it via USB to the serial port. Schematic Code Copy the code from here and paste it into a new sketch in the Arduino IDE and upload the code to the board. After successful uploading open the serial monitor in the IDE by clicking on its button on top right corner. Trying varying the potentiometer\u2019s knob - you should see the stream of values of the serial monitor change. Explanation Whenever the serial port is to be used, it should be initialised with the following line inside void setup(). The 9600 refers to the communication speed in bits-per-second. Serial . begin ( 9600 ); The analogRead function reads the voltage at an analog pin and linearly converts it to a value between 0 and 1023. The Serial.println() function prints a variable to the serial monitor, followed by a newline (using Serial.print() to print data without the newline). The delay(1) is to limit the amount of data printed to the serial monitor. For more tutorials on using Arduino IDE refer to the Basics of Electronics section","title":"Arduino"},{"location":"electronics/Development_Boards/Arduino/#arduino","text":"The Arduino is basically a very accessible and easy to program microcontroller. Unlike other microcontrollers, which need knowledge of registers and ports, the Arduino is programmed by a very basic C-derived language. This video explains what an Arduino is, what it is capable of, and the numerous projects one can use it for.","title":"Arduino"},{"location":"electronics/Development_Boards/Arduino/#arduino-board-layout","text":"The above diagram shows an Arduino UNO board with all the parts labelled and explained below: USB Port: Arduino can be powered by connecting it to your computer using a USB cable. It is also used for uploading code and communicating via the serial port. Power Jack: Used to power an arduino directly from a wall adaptor. Voltage Regulator: Controls and stabilises the voltage used by the Arduino and its components. Crystal Oscillator: A microcontroller is a clock based device. The crystal oscillator present on the arduino generates a clock of frequency 16MHz. Reset controllers: Resetting the arduino board starts the execution of a program from the beginning. Arduino can be reset in 2 ways : by pressing the reset button (17) and sending a 0V signal to the RESET pin (5). 3.3V power 5V power GND (0V) VIN: This pin can be used to power the arduino board from an external power source, from 7-20V. Analog Pins: These pins (labeled A0-A5) can be used to read continuous analog values (between 0 and 5V). They are often used to interface the Arduino with analog sensors. Main Microcontroller: This IC is the main microcontroller, that executes the code you program it with. ICSP Pin: Can be used to program the arduino board\u2019s firmware. For advanced users only. Power LED indicator: Indicates whether the board is powered up correctly. TX/RX LEDs: The TX/RX pins flash to indicate transfer/receival of serial data between the computer and Arduino. Digital I/O Pins: These pins can be programmed as input/output pins. When used as output, they can be set HIGH (+5V) or LOW (0V). Analog Reference(AREF): Can be used to set an external reference voltage(0-5V) as the upper limit for analog input pins. Reset Button: Pressing it causes the Arduino to restart its code.","title":"Arduino Board Layout"},{"location":"electronics/Development_Boards/Arduino/#the-blink-sketch","text":"The Blink sketch is like the \u201cHello World\u201d program in the Arduino world. It simply consists of blinking the onboard LED (labeled \u2018L\u2019). No actual circuit connections are required!","title":"The Blink Sketch"},{"location":"electronics/Development_Boards/Arduino/#code","text":"You can copy the code from here .","title":"Code"},{"location":"electronics/Development_Boards/Arduino/#how-to-code-an-arduino-in-arduino-ide","text":"Download and install Arduino Software (IDE) from here . The Integrated Development Environment (IDE) is a common coding environment for all arduino boards. Open the IDE and a new sketch will open up which would look like the image below. Sketch is just a name arduino uses for a program. Then just paste the entire code here. Now connect your Arduino UNO board to your PC using an A B USB cable and select the option \u201cArduino/Genuino Uno\u201d under Tools > Board menu. Also make sure to select the correct port through which the PC is connected to the board under Tools > Port menu. Click on the \u201ctick\u201d button in upper left corner to compile the code and check for errors. After resolving any and all errors click on the \u201carrow\u201d button next to it to upload the code to the board. After successful upload the Arduino Uno will start executing the code while drawing power from the PC through the USB cable.","title":"How to code an Arduino in Arduino IDE"},{"location":"electronics/Development_Boards/Arduino/#explanation","text":"Every Arduino sketch must have two particular functions: void setup() The setup() function is called when a sketch starts and will only run once, after each powerup or reset of the Arduino board. void loop() This function does precisely what its name suggests, that is loops consecutively, allowing your program to change and respond. Whatever code you write inside loop() will keep running as long as the Arduino is receiving power. Let us examine the Blink sketch now, line by line. int led = 13 ; This line assigns a name to the pin that the LED is attached to, i.e. pin 13. Then we have the setup() function, which runs only once. It includes the following line. pinMode ( led , OUTPUT ); This tells the Arduino to configure that pin as an output. Then we have the following loop() function. void loop () { digitalWrite ( led , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( led , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } The digitalWrite() function tells a pin to either switch on (HIGH, or +5V) or off (LOW, or 0V). The delay() function tells the Arduino to wait for a specified number of milliseconds.","title":"Explanation"},{"location":"electronics/Development_Boards/Arduino/#reading-analog-values","text":"The following circuit reads the voltage from a potentiometer and sends it via USB to the serial port.","title":"Reading Analog Values"},{"location":"electronics/Development_Boards/Arduino/#schematic","text":"","title":"Schematic"},{"location":"electronics/Development_Boards/Arduino/#code_1","text":"Copy the code from here and paste it into a new sketch in the Arduino IDE and upload the code to the board. After successful uploading open the serial monitor in the IDE by clicking on its button on top right corner. Trying varying the potentiometer\u2019s knob - you should see the stream of values of the serial monitor change.","title":"Code"},{"location":"electronics/Development_Boards/Arduino/#explanation_1","text":"Whenever the serial port is to be used, it should be initialised with the following line inside void setup(). The 9600 refers to the communication speed in bits-per-second. Serial . begin ( 9600 ); The analogRead function reads the voltage at an analog pin and linearly converts it to a value between 0 and 1023. The Serial.println() function prints a variable to the serial monitor, followed by a newline (using Serial.print() to print data without the newline). The delay(1) is to limit the amount of data printed to the serial monitor. For more tutorials on using Arduino IDE refer to the Basics of Electronics section","title":"Explanation"},{"location":"mechanical/intro/","text":"Introduction","title":"Introduction"},{"location":"mechanical/intro/#introduction","text":"","title":"Introduction"},{"location":"overview/key_areas/","text":"Key Areas","title":"Key Areas"},{"location":"overview/key_areas/#key-areas","text":"","title":"Key Areas"},{"location":"overview/reference_material/","text":"Reference Material","title":"Reference Material"},{"location":"overview/reference_material/#reference-material","text":"","title":"Reference Material"},{"location":"overview/what_is_robotics/","text":"What is Robotics","title":"What is Robotics?"},{"location":"overview/what_is_robotics/#what-is-robotics","text":"","title":"What is Robotics"},{"location":"simulation/intro/","text":"Introduction Simulation is an essential part of Robotics Automation. They provide a versatile platform to quickly test your code for bugs and performance and try out new ideas. While robots are becoming more accessible all the time, it is still not at the stage where you can test your code directly on them. In fact, running code in simulations will always be more convenient. For a more thorough introduction on simulators and the robots you can find in them, go through Chapter 6 of Morgan Quigley.","title":"Introduction"},{"location":"simulation/intro/#introduction","text":"Simulation is an essential part of Robotics Automation. They provide a versatile platform to quickly test your code for bugs and performance and try out new ideas. While robots are becoming more accessible all the time, it is still not at the stage where you can test your code directly on them. In fact, running code in simulations will always be more convenient. For a more thorough introduction on simulators and the robots you can find in them, go through Chapter 6 of Morgan Quigley.","title":"Introduction"},{"location":"simulation/gazebo/Robot%20Description/","text":"Robot Description 1.) http://gazebosim.org/tutorials?tut=components&cat=get_started 2.) Explaining URDF, SDF, .world and the differences between them 3.) Links on how to write urdf, sdf and .world files 4.) BB8 video tutorial","title":"Robot Description"},{"location":"simulation/gazebo/Robot%20Description/#robot-description","text":"1.) http://gazebosim.org/tutorials?tut=components&cat=get_started 2.) Explaining URDF, SDF, .world and the differences between them 3.) Links on how to write urdf, sdf and .world files 4.) BB8 video tutorial","title":"Robot Description"},{"location":"simulation/gazebo/basics/","text":"Gazebo Gazebo is the most popular physics simulator for robotics development. It can simulate robots in a 3D environment and can be fully integrated into ROS integrated with Gazebo using the gazebo_ros ROS package. You can interface your robots in the simulation using ROS and control them using ROS messages and services. 2.1 Installation Gazebo and gazebo_ros package are both automatically installed when you install ROS. To make sure you have all the ROS packages necessary for running Gazebo simulations are installed sudo apt-get install ros-melodic-gazebo-* Gazebo can also be installed independently of ROS by using the command curl -sSL http://get.gazebosim.org | sh in the terminal for Ubuntu. Alternative methods of installing gazebo and installation guides for installling gazebo on other operating systems can be found here . 2.2 Getting Started You can launch the Gazebo GUI simulator window by just running the command gazebo in the terminal. To understand how to spawn robot models in gazebo it is recommended to first get familiar with .urdf , .sdf and .world files. You can refer to the Robot Description section to read about these. A file can be opened simply by running the follwing command in the command line: gazebo <path/to/file> 2.3 Client Server Separation Running the gazebo command starts two programmes, namely the gzserver and the gzclient . The gzserver is responsible for doing most of the \u2018processing\u2019 part, i.e., doing all the calculations for the simulation, sensor data generation, basically all the backend processing. The gzclient is responsible for generating the user interface. It provides a nice visualization of simulation, and convenient controls over various simulation properties. gzserver is capable of running independently of gzclient and vice-versa. For eg; in many cases gzserver is run on a cloud computer in case enough processing power is not available locally. Try running the command gzserver in one terminal and the command gzclient in other terminal. You will notice that the gazebo window pops up only when you run the gzclient command. The term run headless is used to refer to cases when only the gzserver is being used. 2.4 Environment Variables in Gazebo Environment Variables are variables whose values are valid throughout the system and are used by different applications and the OS for several purposes. These environment variables can contain different types of things ranging from parameter values to paths to certain files depending on what they are used for. Gazebo uses various such environment variables too. These variables and their uses are described below: GAZEBO_MODEL_PATH : This environment variable contains colon-separated paths to different directories where gazebo will search for models. Models refers to the sdf file describing the robot. For more information on this refer to the Robot Description section of the handbook. GAZEBO_RESOURCE_PATH: This environment variable contains colon-separated set of directories where Gazebo will search for other resources such as world and media files. For eg. if you run the command gazebo worlds/pioneer2dx.world . You will see gazebo window pop up with an empty environment. In fact you can execute this command in any directory. You might ask how does gazebo know where the worlds directory is stored?. The answer is that the path to the world directory, that is /usr/share/gazebo-7/worlds is stored in the environment variable GAZEBO_RESOURCE_PATH . GAZEBO_MASTER__URI: URI of the Gazebo master . This specifies the IP and port where the server(gzserver) will be started and tells the clients(gzclients) where to connect to. GAZEBO_PLUGIN_PATH: colon-separated set of directories where Gazebo will search for the plugin shared libraries at runtime. Plugins are basically..... You can refer to this section to read more about gazebo plugins. GAZEBO_MODEL_DATABASE_URI: URI of the online model database where Gazebo will download models from. The default values of these environment variables are stored in the <install_path>/share/gazebo/setup.sh file. If you want to change the values of this variables for example, add or remove a path from GITHUB_MODEL_PATH you will have to source this file first using the command source <install_path>/share/gazebo/setup.sh Once this is done you can edit that value of the variable by editing the value by opening the setup.sh file or directly thorugh the terminal/command line using the command: GITHUB_MODEL_PATH=$GITHUB_MODEL_PATH:<path of the directory you want to add>","title":"Basics of Gazebo"},{"location":"simulation/gazebo/basics/#gazebo","text":"Gazebo is the most popular physics simulator for robotics development. It can simulate robots in a 3D environment and can be fully integrated into ROS integrated with Gazebo using the gazebo_ros ROS package. You can interface your robots in the simulation using ROS and control them using ROS messages and services.","title":"Gazebo"},{"location":"simulation/gazebo/basics/#21-installation","text":"Gazebo and gazebo_ros package are both automatically installed when you install ROS. To make sure you have all the ROS packages necessary for running Gazebo simulations are installed sudo apt-get install ros-melodic-gazebo-* Gazebo can also be installed independently of ROS by using the command curl -sSL http://get.gazebosim.org | sh in the terminal for Ubuntu. Alternative methods of installing gazebo and installation guides for installling gazebo on other operating systems can be found here .","title":"2.1 Installation"},{"location":"simulation/gazebo/basics/#22-getting-started","text":"You can launch the Gazebo GUI simulator window by just running the command gazebo in the terminal. To understand how to spawn robot models in gazebo it is recommended to first get familiar with .urdf , .sdf and .world files. You can refer to the Robot Description section to read about these. A file can be opened simply by running the follwing command in the command line: gazebo <path/to/file>","title":"2.2 Getting Started"},{"location":"simulation/gazebo/basics/#23-client-server-separation","text":"Running the gazebo command starts two programmes, namely the gzserver and the gzclient . The gzserver is responsible for doing most of the \u2018processing\u2019 part, i.e., doing all the calculations for the simulation, sensor data generation, basically all the backend processing. The gzclient is responsible for generating the user interface. It provides a nice visualization of simulation, and convenient controls over various simulation properties. gzserver is capable of running independently of gzclient and vice-versa. For eg; in many cases gzserver is run on a cloud computer in case enough processing power is not available locally. Try running the command gzserver in one terminal and the command gzclient in other terminal. You will notice that the gazebo window pops up only when you run the gzclient command. The term run headless is used to refer to cases when only the gzserver is being used.","title":"2.3 Client Server Separation"},{"location":"simulation/gazebo/basics/#24-environment-variables-in-gazebo","text":"Environment Variables are variables whose values are valid throughout the system and are used by different applications and the OS for several purposes. These environment variables can contain different types of things ranging from parameter values to paths to certain files depending on what they are used for. Gazebo uses various such environment variables too. These variables and their uses are described below: GAZEBO_MODEL_PATH : This environment variable contains colon-separated paths to different directories where gazebo will search for models. Models refers to the sdf file describing the robot. For more information on this refer to the Robot Description section of the handbook. GAZEBO_RESOURCE_PATH: This environment variable contains colon-separated set of directories where Gazebo will search for other resources such as world and media files. For eg. if you run the command gazebo worlds/pioneer2dx.world . You will see gazebo window pop up with an empty environment. In fact you can execute this command in any directory. You might ask how does gazebo know where the worlds directory is stored?. The answer is that the path to the world directory, that is /usr/share/gazebo-7/worlds is stored in the environment variable GAZEBO_RESOURCE_PATH . GAZEBO_MASTER__URI: URI of the Gazebo master . This specifies the IP and port where the server(gzserver) will be started and tells the clients(gzclients) where to connect to. GAZEBO_PLUGIN_PATH: colon-separated set of directories where Gazebo will search for the plugin shared libraries at runtime. Plugins are basically..... You can refer to this section to read more about gazebo plugins. GAZEBO_MODEL_DATABASE_URI: URI of the online model database where Gazebo will download models from. The default values of these environment variables are stored in the <install_path>/share/gazebo/setup.sh file. If you want to change the values of this variables for example, add or remove a path from GITHUB_MODEL_PATH you will have to source this file first using the command source <install_path>/share/gazebo/setup.sh Once this is done you can edit that value of the variable by editing the value by opening the setup.sh file or directly thorugh the terminal/command line using the command: GITHUB_MODEL_PATH=$GITHUB_MODEL_PATH:<path of the directory you want to add>","title":"2.4 Environment Variables in Gazebo"}]}